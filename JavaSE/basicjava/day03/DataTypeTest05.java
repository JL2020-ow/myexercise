/*关于java中的整数型
 byte 
 short
 int
 long
*/
public class DataTypeTest05
{
	public static void main(String[] args)
	{    //100L是long类型字面值
		//x是long类型变量
		//不存在类型转换，直接赋值
		long x=100L;
		//x变量是long类型，8个字节
		//y变量是int类型，4个字节
		//以下程序可以编译通过吗？
		//编译报错，大容量不能直接赋值给小容量
		//int y=x;

		//大容量转换成小容量，需要进行强制类型转换
		//强制类型转换需要加“强制类型转换符”
		//加上强制类型转换之后编译通过了，但是运行阶段可能损失精度。
		//所以强制类型转换谨慎使用，因为损失精度之后损失很严重。
		//强转原理：
		     //原始数据 00000000 00000000 00000000 00000000 00000000 00000000 00000000 01100100
			 //强转之后的数据 00000000 00000000 00000000 01100100
			 //将左边的二进制砍掉【所有的数据强转的时候都是这样完成的】
		int y=(int)x;
		System.out.println(y);

        //原始数据 00000000 00000000 00000000 00000000 10000000 00000000 00000000 00000000
	   //强转之后的数据 10000000 00000000 00000000 00000000
	   //10000000 00000000 00000000 00000000目前存储在计算机内部，计算机存储数据都是采用补码的形式存储
	   //所以10000000 00000000 00000000 00000000现在是一个补码形式
	   //将以上的补码转换到原码就是最终的结果。
		long k=2147483648L;
		int e=(int)k;
		System.out.println(e);//损失精度严重，结果是负数 【-2147483648】
        
		//分析一下程序是否可以编译通过？
		//依据目前所学内容：以下程序是无法编译通过的
		//理由：50是int类型的字面值，b是byte类型的变量
		//显然是大容量int转换成小容量byte
		//大容量转换成小容量是要添加强制类型转换符的，以下程序没有添加强转符号，所以编译报错。
		//但是在实际编译过程中以下程序编译通过，这说明，在java语言当中，当一个整数型字面值
		//没有超出byte类型取值范围的话，该字面值可以直接赋值给byte的变量。
		byte b=50;//可以

		byte c=127;//可以

		//byte b1=128; 8//超出byte类型取值范围，不能直接赋值给byte类型的变量
		//但是一定会损失精度
		//原始数据：00000000 00000000 00000000 10000000
		//强转之后：10000000【这是存储在计算机内部的，这是一个补码，它的原码是什么？】
        byte b1=(byte)128;//-128
		System.out.println(b1);
		//正数的补码与原码相同；负数的补码，将其对应的二进制表示所有位取反（包括符号位，0变1,1变0）后加1。
		/*
		   计算机二进制有三种表示形式：
		           原码
				   反码
				   补码
		   计算机在任何情况下底层表示和存储数据的时候采取了补码形式。
		   正数的补码：和原码相同
		   负数的补码：负数的绝对值对应的二进制码所有二进制位取反，再加1 */
		   byte m=(byte)198;
		   System.out.println(m); //-58


		   short s=32767;//通过
		   short s1=32768;//编译报错
           
		   //65536是int类型，4个字节
		   //cc是char类型，2个字节
		   //按照以前所学知识点，以下程序是编译报错的
		   char cc=65535;//通过
		   //cc=65536;//编译报错

		   /*
		     当一个整数字面值没有超出byte,short,char的取值范围，这个字面值可以直接赋值给byte,
			 short,char类型的变量。这种机制SUN允许了，目的是为了方便程序员的编程。
		   */
		 


	}

}
//补码10000000
//减1
//01111111
//反码10000000 128

//原码：-128